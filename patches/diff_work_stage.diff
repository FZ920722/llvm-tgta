diff --git a/llvm/CMakeLists.txt b/llvm/CMakeLists.txt
index 2da05ef870b9..b4b5f8e966de 100644
--- a/llvm/CMakeLists.txt
+++ b/llvm/CMakeLists.txt
@@ -1241,22 +1241,6 @@ if (MSVC AND CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows" AND CMAKE_INSTALL_UCRT_LI
   include(InstallRequiredSystemLibraries)
 endif()
 
-if (LLVM_INCLUDE_BENCHMARKS)
-  # Override benchmark defaults so that when the library itself is updated these
-  # modifications are not lost.
-  set(BENCHMARK_ENABLE_TESTING OFF CACHE BOOL "Disable benchmark testing" FORCE)
-  set(BENCHMARK_ENABLE_EXCEPTIONS OFF CACHE BOOL "Disable benchmark exceptions" FORCE)
-  set(BENCHMARK_ENABLE_INSTALL OFF CACHE BOOL "Don't install benchmark" FORCE)
-  set(BENCHMARK_DOWNLOAD_DEPENDENCIES OFF CACHE BOOL "Don't download dependencies" FORCE)
-  set(BENCHMARK_ENABLE_GTEST_TESTS OFF CACHE BOOL "Disable Google Test in benchmark" FORCE)
-  set(BENCHMARK_ENABLE_WERROR ${LLVM_ENABLE_WERROR} CACHE BOOL 
-    "Handle -Werror for Google Benchmark based on LLVM_ENABLE_WERROR" FORCE)
-  # Since LLVM requires C++11 it is safe to assume that std::regex is available.
-  set(HAVE_STD_REGEX ON CACHE BOOL "OK" FORCE)
-  add_subdirectory(${LLVM_THIRD_PARTY_DIR}/benchmark 
-    ${CMAKE_CURRENT_BINARY_DIR}/third-party/benchmark)
-  add_subdirectory(benchmarks)
-endif()
 
 if (LLVM_INCLUDE_UTILS AND LLVM_INCLUDE_TOOLS)
   add_subdirectory(utils/llvm-locstats)
diff --git a/llvm/include/llvm/Analysis/LoopInfo.h b/llvm/include/llvm/Analysis/LoopInfo.h
index a0ffdb07a7ec..82575f16c246 100644
--- a/llvm/include/llvm/Analysis/LoopInfo.h
+++ b/llvm/include/llvm/Analysis/LoopInfo.h
@@ -925,11 +925,11 @@ public:
   void releaseMemory() {
     BBMap.clear();
 
-    for (auto *L : TopLevelLoops)
-      L->~LoopT();
+    // for (auto *L : TopLevelLoops)
+    //   L->~LoopT();
     TopLevelLoops.clear();
-    LoopAllocator.Reset();
-  }
+  //   LoopAllocator.Reset();
+   }
 
   template <typename... ArgsTy> LoopT *AllocateLoop(ArgsTy &&... Args) {
     LoopT *Storage = LoopAllocator.Allocate<LoopT>();
diff --git a/llvm/include/llvm/Analysis/ScalarEvolution.h b/llvm/include/llvm/Analysis/ScalarEvolution.h
index b16aa7017719..abed608f15d8 100644
--- a/llvm/include/llvm/Analysis/ScalarEvolution.h
+++ b/llvm/include/llvm/Analysis/ScalarEvolution.h
@@ -140,7 +140,7 @@ public:
   explicit SCEV(const FoldingSetNodeIDRef ID, SCEVTypes SCEVTy,
                 unsigned short ExpressionSize)
       : FastID(ID), SCEVType(SCEVTy), ExpressionSize(ExpressionSize) {}
-  SCEV(const SCEV &) = delete;
+  // SCEV(const SCEV &) = delete;
   SCEV &operator=(const SCEV &) = delete;
 
   SCEVTypes getSCEVType() const { return SCEVType; }
diff --git a/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h b/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
index cd8e5fab6766..7baa90bac927 100644
--- a/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
+++ b/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
@@ -589,6 +589,10 @@ class SCEVUnknown final : public SCEV, private CallbackVH {
   void allUsesReplacedWith(Value *New) override;
 
 public:
+  // Modified By Zeng-WCh
+  // for bug fixed when trying to copy a SCEV instant
+  bool IsCopied = false;
+  // End of Modification
   Value *getValue() const { return getValPtr(); }
 
   /// @{
diff --git a/llvm/lib/Analysis/ScalarEvolution.cpp b/llvm/lib/Analysis/ScalarEvolution.cpp
index 977fc0911355..2657d3e44c8a 100644
--- a/llvm/lib/Analysis/ScalarEvolution.cpp
+++ b/llvm/lib/Analysis/ScalarEvolution.cpp
@@ -508,6 +508,13 @@ SCEVSignExtendExpr::SCEVSignExtendExpr(const FoldingSetNodeIDRef ID,
 }
 
 void SCEVUnknown::deleted() {
+  // Modified By Zeng-WCh
+  // for bug fixed when trying to copy a scev instant
+  if (this->IsCopied) {
+    setValPtr(nullptr);
+    return;
+  }
+  // End of Modification
   // Clear this SCEVUnknown from various maps.
   SE->forgetMemoizedResults(this);
 
@@ -13506,6 +13513,7 @@ ScalarEvolutionWrapperPass::ScalarEvolutionWrapperPass() : FunctionPass(ID) {
 }
 
 bool ScalarEvolutionWrapperPass::runOnFunction(Function &F) {
+  SE.release();
   SE.reset(new ScalarEvolution(
       F, getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F),
       getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F),
diff --git a/llvm/lib/CodeGen/MachineModuleInfo.cpp b/llvm/lib/CodeGen/MachineModuleInfo.cpp
index 31d4fc7d02bf..ce03b3199b9f 100644
--- a/llvm/lib/CodeGen/MachineModuleInfo.cpp
+++ b/llvm/lib/CodeGen/MachineModuleInfo.cpp
@@ -313,7 +313,7 @@ MachineFunction &MachineModuleInfo::getOrCreateMachineFunction(Function &F) {
 }
 
 void MachineModuleInfo::deleteMachineFunctionFor(Function &F) {
-  MachineFunctions.erase(&F);
+  //MachineFunctions.erase(&F);
   LastRequest = nullptr;
   LastResult = nullptr;
 }
diff --git a/llvm/lib/Transforms/Utils/HelloWorld.cpp b/llvm/lib/Transforms/Utils/HelloWorld.cpp
index 7019e9e4451b..b998e2a453c2 100644
--- a/llvm/lib/Transforms/Utils/HelloWorld.cpp
+++ b/llvm/lib/Transforms/Utils/HelloWorld.cpp
@@ -7,11 +7,71 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/Transforms/Utils/HelloWorld.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/IR/InlineAsm.h"
+#include "llvm/IR/LLVMContext.h"
+#include "llvm/IR/PassManager.h"
+#include "llvm/IR/Instructions.h"
+
+#include "llvm/Support/raw_ostream.h"
 
 using namespace llvm;
 
-PreservedAnalyses HelloWorldPass::run(Function &F,
-                                      FunctionAnalysisManager &AM) {
-  errs() << F.getName() << "\n";
-  return PreservedAnalyses::all();
+PreservedAnalyses HelloWorldPass::run(Function &F, FunctionAnalysisManager &AM) {
+
+  if (F.hasFnAttribute(Attribute::NoReturn)) {
+    F.deleteBody();
+    return PreservedAnalyses::none();
+  }
+  bool IRModified = false;
+
+  // 若存在 inline asm，删除整个函数体
+  for (auto &BB : F) {
+    for (auto &I : BB) {
+      if (auto *CI = dyn_cast<CallInst>(&I)) {
+        if (CI->isInlineAsm()) {
+          F.deleteBody();
+          return PreservedAnalyses::none();
+        }
+      }
+    }
+  }
+
+  // Module *M = F.getParent();
+  // Function *DoNothing = Intrinsic::getDeclaration(M, Intrinsic::donothing);
+
+  for (auto &BB : F) {
+    for (auto instI = BB.begin(), instE = BB.end(); instI != instE; ) {
+      Instruction &I = *instI++;
+      if (auto *callInst = dyn_cast<CallInst>(&I)) {
+        Function *calledFunc = callInst->getCalledFunction();
+        bool IsNoReturn = callInst->hasFnAttr(Attribute::NoReturn) || (calledFunc && calledFunc->hasFnAttribute(Attribute::NoReturn));
+        if (!IsNoReturn)
+          continue;
+
+        // 1. 插入空操作
+        // IRBuilder<> B(callInst);
+        // B.CreateCall(DoNothing);
+
+        // 2. 移除 call 上的 noreturn
+        callInst->removeFnAttr(Attribute::NoReturn);
+
+        // 3. 若被调函数是 noreturn，仅移除 call，不动 callee
+        // callInst->eraseFromParent();
+
+        IRModified = true;
+      }
+    }
+  }
+
+  // 4. 如果当前函数被标成 noreturn，必须移除
+  if (F.hasFnAttribute(Attribute::NoReturn)) {
+    F.removeFnAttr(Attribute::NoReturn);
+    IRModified = true;
+  }
+
+  return IRModified ? PreservedAnalyses::none()
+                    : PreservedAnalyses::all();
 }
